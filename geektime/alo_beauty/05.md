[source](https://time.geekbang.org/column/article/40961)

数组从0开始编号
数组是一组连续的内存内容， base_address开始， 根据偏移量计算出地址， 拿出值。 所以从0开始， 有利于地址的计算


不仅是数据类型， 还是一种最基础的数据结构， 精髓何处？

思维习惯从1开始
数组是一种线性表数据结构， 用一组连续的内存空间， 来存储一组具有相同类型的数据。

线性表  Linear List  一条线一样的结构。 
数据 和前后两个方向

连续的内存空间和相同类型的数据。 随机访问。 低效， 删除， 插入一个数据， 大量的数据搬移工作。
每个内存单元分配一个地址， 通过地址来访问内存中的数据。
int 类型数据， 4个字节
链表适合插入、删除，时间复杂度为O(1), 数组适合查找， 时间复杂度为O(1). 二分查找， 时间复杂度也是O(logn)。 数组支持随机访问， 根据下标随机访问的时间复杂度为O(1)

插入情况：
未尾  O（1）
某个位置  将k位后的数据搬移到数组元素的最后， 把新的元素放入第K个位置。
最差队头
多次删除操作集中在一起
当数组没有更多空间存储数据时， 我们触发一次真正的删除操作。

数组越界。

从数组的内存模型上看， 下标最确切的定义应该是offset,  a 数组的首地址， a[0]就是偏移为0的位置， a[k] k个type_size的位置， 
a[k]_address = base_address + k * type_size

a[i][j]_address = base_address + j*type_size*(i+1)

线性表， 数组 链表  队列  栈 
非线性表  树 图 堆
随机访问来自于连续的内存空间， 相同类型的数据。 
a[i]_address = base_address + i*data_type_size

插入 

数组越界问题
而这个地址正好是存储变量i的内存地址， a[3]=0